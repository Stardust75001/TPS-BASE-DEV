#!/bin/bash

# üöÄ SCRIPT DE SYNCHRONISATION AUTOMATIQUE GITHUB
# Usage: ./auto-push-github.sh [mode]
# Modes: quick, safe, force

set -e

# Configuration
REPO_NAME="TPS-BASE-DEV"
OWNER="Stardust75001"
MAIN_BRANCH="main"
BACKUP_PREFIX="backup/auto-push"
LOG_FILE="sync_$(date +%Y%m%d_%H%M%S).log"

# Couleurs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Mode par d√©faut
MODE=${1:-"safe"}

echo -e "${CYAN}üöÄ SYNCHRONISATION AUTOMATIQUE GITHUB${NC}"
echo -e "${BLUE}========================================${NC}"
echo -e "üìÖ Date: $(date '+%d/%m/%Y √† %H:%M')"
echo -e "üéØ Mode: $MODE"
echo -e "üìÅ Repository: $OWNER/$REPO_NAME"
echo ""

# Fonction de logging
log() {
    echo "[$(date '+%H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# Fonction de v√©rification des pr√©requis
check_prerequisites() {
    log "üîç V√©rification des pr√©requis..."

    # V√©rifier Git
    if ! command -v git &> /dev/null; then
        echo -e "${RED}‚ùå Git n'est pas install√©${NC}"
        exit 1
    fi

    # V√©rifier Python3
    if ! command -v python3 &> /dev/null; then
        echo -e "${RED}‚ùå Python3 n'est pas install√©${NC}"
        exit 1
    fi

    # V√©rifier qu'on est dans un repo git
    if [ ! -d ".git" ]; then
        echo -e "${RED}‚ùå Ce r√©pertoire n'est pas un repository Git${NC}"
        exit 1
    fi

    # V√©rifier la connexion √† GitHub
    if ! git remote get-url origin &> /dev/null; then
        echo -e "${RED}‚ùå Aucun remote origin configur√©${NC}"
        exit 1
    fi

    echo -e "${GREEN}‚úÖ Tous les pr√©requis sont satisfaits${NC}"
}

# Analyse de l'√©tat actuel
analyze_repository_state() {
    log "üìä Analyse de l'√©tat du repository..."

    # R√©cup√©rer les infos depuis origin
    git fetch origin $MAIN_BRANCH 2>/dev/null || {
        echo -e "${YELLOW}‚ö†Ô∏è Impossible de fetch origin, tentative de continue...${NC}"
    }

    # Compter les changements
    UNCOMMITTED=$(git status --porcelain | wc -l | tr -d ' ')
    UNTRACKED=$(git ls-files --others --exclude-standard | wc -l | tr -d ' ')

    # V√©rifier la position par rapport √† origin
    AHEAD=$(git rev-list --count origin/$MAIN_BRANCH..HEAD 2>/dev/null || echo "0")
    BEHIND=$(git rev-list --count HEAD..origin/$MAIN_BRANCH 2>/dev/null || echo "0")

    echo -e "${BLUE}üìà √âtat du repository:${NC}"
    echo -e "   üìù Fichiers modifi√©s/staged: $UNCOMMITTED"
    echo -e "   üìÅ Fichiers non track√©s: $UNTRACKED"
    echo -e "   ‚¨ÜÔ∏è Commits en avance: $AHEAD"
    echo -e "   ‚¨áÔ∏è Commits en retard: $BEHIND"

    # D√©terminer si une sync est n√©cessaire
    TOTAL_CHANGES=$((UNCOMMITTED + UNTRACKED))
    if [ $TOTAL_CHANGES -gt 0 ]; then
        log "üîÑ Synchronisation n√©cessaire: $TOTAL_CHANGES changement(s)"
        SYNC_NEEDED=true
    else
        log "‚úÖ Repository d√©j√† synchronis√©"
        SYNC_NEEDED=false
    fi

    # V√©rifier les conflits potentiels
    if [ $BEHIND -gt 0 ] && [ $AHEAD -gt 0 ]; then
        echo -e "${YELLOW}‚ö†Ô∏è Divergence d√©tect√©e: merge/rebase n√©cessaire${NC}"
        CONFLICTS_POSSIBLE=true
    else
        CONFLICTS_POSSIBLE=false
    fi
}

# Audit de s√©curit√© rapide
security_audit() {
    log "üîí Audit de s√©curit√©..."

    SECURITY_ISSUES=0

    # V√©rifier les secrets Shopify
    SHOPIFY_SECRETS=$(grep -r "sk_live_\|pk_live_" --include="*.liquid" --include="*.js" . 2>/dev/null | wc -l | tr -d ' ')
    if [ $SHOPIFY_SECRETS -gt 0 ]; then
        echo -e "${RED}üö® CRITIQUE: $SHOPIFY_SECRETS secret(s) Shopify d√©tect√©(s)${NC}"
        SECURITY_ISSUES=$((SECURITY_ISSUES + SHOPIFY_SECRETS))
    fi

    # V√©rifier les API keys
    API_KEYS=$(grep -r "AIza[A-Za-z0-9]\{35\}" --include="*.liquid" --include="*.js" . 2>/dev/null | wc -l | tr -d ' ')
    if [ $API_KEYS -gt 0 ]; then
        echo -e "${RED}üö® $API_KEYS cl√©(s) API expos√©e(s)${NC}"
        SECURITY_ISSUES=$((SECURITY_ISSUES + API_KEYS))
    fi

    # V√©rifier les tokens GitHub
    GH_TOKENS=$(grep -r "ghp_\|gho_\|ghu_\|ghs_\|ghr_" --include="*.liquid" --include="*.js" . 2>/dev/null | wc -l | tr -d ' ')
    if [ GH_TOKENS -gt 0 ]; then
        echo -e "${RED}üö® $GH_TOKENS token(s) GitHub expos√©(s)${NC}"
        SECURITY_ISSUES=$((SECURITY_ISSUES + GH_TOKENS))
    fi

    if [ $SECURITY_ISSUES -gt 0 ]; then
        echo -e "${RED}‚ùå $SECURITY_ISSUES probl√®me(s) de s√©curit√© d√©tect√©(s)${NC}"
        if [ "$MODE" != "force" ]; then
            echo -e "${RED}üõë SYNC BLOQU√âE: Corrigez les probl√®mes de s√©curit√© d'abord${NC}"
            exit 1
        else
            echo -e "${YELLOW}‚ö†Ô∏è Mode force activ√©: continuation malgr√© les probl√®mes${NC}"
        fi
    else
        echo -e "${GREEN}‚úÖ Aucun probl√®me de s√©curit√© d√©tect√©${NC}"
    fi
}

# Validation des fichiers
validate_files() {
    log "üìù Validation des fichiers..."

    # Valider les JSON
    JSON_ERRORS=0
    if [ -d "locales" ]; then
        for file in locales/*.json; do
            if [ -f "$file" ]; then
                if python3 -m json.tool "$file" > /dev/null 2>&1; then
                    echo -e "${GREEN}   ‚úÖ $(basename "$file")${NC}"
                else
                    echo -e "${RED}   ‚ùå $(basename "$file") - Erreur JSON${NC}"
                    JSON_ERRORS=$((JSON_ERRORS + 1))
                fi
            fi
        done
    fi

    if [ $JSON_ERRORS -gt 0 ]; then
        echo -e "${YELLOW}‚ö†Ô∏è $JSON_ERRORS erreur(s) JSON d√©tect√©e(s)${NC}"
        if [ "$MODE" == "safe" ]; then
            echo -e "${RED}üõë Mode safe: corrigez les erreurs JSON d'abord${NC}"
            exit 1
        fi
    fi

    log "‚úÖ Validation termin√©e"
}

# Nettoyage intelligent
intelligent_cleanup() {
    log "üßπ Nettoyage intelligent..."

    # Supprimer les fichiers temporaires
    find . -name "*.bak" -delete 2>/dev/null || true
    find . -name "*.tmp" -delete 2>/dev/null || true
    find . -name ".DS_Store" -delete 2>/dev/null || true
    find . -name "Thumbs.db" -delete 2>/dev/null || true

    # Corriger les permissions des scripts
    chmod +x *.sh 2>/dev/null || true
    chmod +x scripts/*.sh 2>/dev/null || true

    # Moderniser les filtres Shopify (si peu de fichiers)
    LIQUID_COUNT=$(find . -name "*.liquid" | wc -l | tr -d ' ')
    if [ $LIQUID_COUNT -lt 100 ]; then
        DEPRECATED_COUNT=$(find . -name "*.liquid" -exec grep -l "img_url" {} \; | wc -l | tr -d ' ')
        if [ $DEPRECATED_COUNT -gt 0 ]; then
            log "üîÑ Modernisation de $DEPRECATED_COUNT filtre(s) Shopify..."
            find . -name "*.liquid" -exec sed -i.bak 's/| *img_url/| image_url/g' {} \; 2>/dev/null || true
            find . -name "*.bak" -delete 2>/dev/null || true
        fi
    fi

    # Nettoyer les console.log (si peu)
    CONSOLE_COUNT=$(grep -r "console\." --include="*.liquid" . 2>/dev/null | wc -l | tr -d ' ')
    if [ $CONSOLE_COUNT -lt 10 ] && [ $CONSOLE_COUNT -gt 0 ]; then
        log "üßπ Nettoyage de $CONSOLE_COUNT console.log..."
        find . -name "*.liquid" -exec sed -i.bak 's/console\.log([^;]*);*//g' {} \; 2>/dev/null || true
        find . -name "*.bak" -delete 2>/dev/null || true
    fi

    log "‚úÖ Nettoyage termin√©"
}

# Cr√©er un backup de s√©curit√©
create_backup() {
    log "üì¶ Cr√©ation du backup de s√©curit√©..."

    BACKUP_BRANCH="${BACKUP_PREFIX}-$(date +%Y%m%d_%H%M%S)"

    # Sauvegarder l'√©tat actuel sur une nouvelle branche
    git checkout -b "$BACKUP_BRANCH" 2>/dev/null || {
        echo -e "${YELLOW}‚ö†Ô∏è Impossible de cr√©er la branche backup${NC}"
        return 1
    }

    # Ajouter tous les fichiers au backup
    git add . 2>/dev/null || true
    git commit -m "üóÑÔ∏è Backup automatique avant sync: $(date)" 2>/dev/null || {
        echo -e "${YELLOW}‚ö†Ô∏è Rien √† sauvegarder${NC}"
    }

    # Retourner sur main
    git checkout $MAIN_BRANCH

    # Pousser le backup (optionnel)
    if [ "$MODE" == "safe" ] || [ "$MODE" == "quick" ]; then
        git push origin "$BACKUP_BRANCH" 2>/dev/null || {
            echo -e "${YELLOW}‚ö†Ô∏è Impossible de pousser le backup sur origin${NC}"
        }
    fi

    echo -e "${GREEN}‚úÖ Backup cr√©√©: $BACKUP_BRANCH${NC}"
}

# Strat√©gie de commit intelligente
intelligent_commit() {
    log "üíæ Strat√©gie de commit intelligente..."

    if [ -z "$(git status --porcelain)" ]; then
        log "‚ÑπÔ∏è Aucun changement √† commiter"
        return 0
    fi

    # Analyser les types de fichiers modifi√©s
    LIQUID_CHANGES=$(git status --porcelain | grep -c "\.liquid$" || echo "0")
    JSON_CHANGES=$(git status --porcelain | grep -c "\.json$" || echo "0")
    JS_CHANGES=$(git status --porcelain | grep -c "\.js$" || echo "0")
    CSS_CHANGES=$(git status --porcelain | grep -c "\.css$" || echo "0")
    CONFIG_CHANGES=$(git status --porcelain | grep -c -E "\.(yml|yaml|sh|md)$" || echo "0")

    # Construire un message de commit intelligent
    COMMIT_PARTS=()
    [ $LIQUID_CHANGES -gt 0 ] && COMMIT_PARTS+=("Templates ($LIQUID_CHANGES)")
    [ $JSON_CHANGES -gt 0 ] && COMMIT_PARTS+=("Locales ($JSON_CHANGES)")
    [ $JS_CHANGES -gt 0 ] && COMMIT_PARTS+=("Scripts ($JS_CHANGES)")
    [ $CSS_CHANGES -gt 0 ] && COMMIT_PARTS+=("Styles ($CSS_CHANGES)")
    [ $CONFIG_CHANGES -gt 0 ] && COMMIT_PARTS+=("Config ($CONFIG_CHANGES)")

    # Message principal
    if [ ${#COMMIT_PARTS[@]} -eq 1 ]; then
        COMMIT_MSG="üîß Update ${COMMIT_PARTS[0]}"
    elif [ ${#COMMIT_PARTS[@]} -le 3 ]; then
        COMMIT_MSG="üöÄ Auto-sync: $(IFS=', '; echo "${COMMIT_PARTS[*]}")"
    else
        COMMIT_MSG="üöÄ Auto-sync: Multiple updates ($(date +%Y%m%d))"
    fi

    # Message d√©taill√©
    COMMIT_BODY="üîß Optimisations automatiques:
- Filtres Shopify modernis√©s
- Console.log nettoy√©s
- Fichiers temporaires supprim√©s
- Permissions corrig√©es

üìä R√©sum√© des changements:
- Templates Liquid: $LIQUID_CHANGES
- Fichiers de traduction: $JSON_CHANGES
- Scripts JavaScript: $JS_CHANGES
- Feuilles de style: $CSS_CHANGES
- Configuration: $CONFIG_CHANGES

ü§ñ Commit automatique g√©n√©r√© le $(date '+%d/%m/%Y √† %H:%M')"

    # Effectuer le commit
    git add .
    git commit -m "$COMMIT_MSG" -m "$COMMIT_BODY"

    log "‚úÖ Commit cr√©√©: $COMMIT_MSG"
}

# Push avec gestion des conflits
smart_push() {
    log "üì§ Push intelligent vers GitHub..."

    # V√©rifier s'il y a des commits √† pousser
    COMMITS_TO_PUSH=$(git rev-list --count origin/$MAIN_BRANCH..HEAD 2>/dev/null || echo "0")

    if [ $COMMITS_TO_PUSH -eq 0 ]; then
        log "‚ÑπÔ∏è Aucun commit √† pousser"
        return 0
    fi

    echo -e "${BLUE}üì§ $COMMITS_TO_PUSH commit(s) √† pousser...${NC}"

    # Tentative de push simple
    if git push origin $MAIN_BRANCH 2>/dev/null; then
        echo -e "${GREEN}‚úÖ Push r√©ussi!${NC}"
        return 0
    fi

    # En cas d'√©chec, analyser la situation
    log "‚ö†Ô∏è Push √©chou√©, analyse..."

    # R√©cup√©rer les derni√®res modifications
    git fetch origin $MAIN_BRANCH

    BEHIND_AFTER_FETCH=$(git rev-list --count HEAD..origin/$MAIN_BRANCH 2>/dev/null || echo "0")

    if [ $BEHIND_AFTER_FETCH -gt 0 ]; then
        echo -e "${YELLOW}üîÑ Repository en retard de $BEHIND_AFTER_FETCH commit(s)${NC}"

        if [ "$MODE" == "force" ]; then
            log "üö® Mode force: push forc√©"
            git push --force-with-lease origin $MAIN_BRANCH
        else
            log "üîÑ Tentative de rebase automatique..."
            if git rebase origin/$MAIN_BRANCH; then
                log "‚úÖ Rebase r√©ussi, nouveau push..."
                git push origin $MAIN_BRANCH
            else
                echo -e "${RED}‚ùå Conflits de merge d√©tect√©s${NC}"
                echo -e "${YELLOW}üí° Actions possibles:${NC}"
                echo -e "   1. R√©soudre manuellement: git rebase --continue"
                echo -e "   2. Annuler: git rebase --abort"
                echo -e "   3. Forcer: ./$(basename $0) force"
                exit 1
            fi
        fi
    else
        echo -e "${RED}‚ùå Erreur de push inconnue${NC}"
        exit 1
    fi
}

# Rapport final
generate_report() {
    log "üìä G√©n√©ration du rapport final..."

    REPORT_FILE="sync_report_$(date +%Y%m%d_%H%M%S).md"

    cat > "$REPORT_FILE" << EOF
# üöÄ Rapport de Synchronisation GitHub

**üìÖ Date**: $(date '+%d/%m/%Y √† %H:%M')
**üéØ Mode**: $MODE
**üìÅ Repository**: $OWNER/$REPO_NAME
**üåø Branche**: $MAIN_BRANCH

## üìä √âtat Initial

- **Fichiers modifi√©s**: $UNCOMMITTED
- **Fichiers non track√©s**: $UNTRACKED
- **Commits en avance**: $AHEAD
- **Commits en retard**: $BEHIND

## üîí S√©curit√©

- **Secrets Shopify**: $SHOPIFY_SECRETS
- **Cl√©s API**: $API_KEYS
- **Tokens GitHub**: $GH_TOKENS
- **üéØ Status**: $([ $SECURITY_ISSUES -eq 0 ] && echo "‚úÖ S√âCURIS√â" || echo "‚ùå PROBL√àMES D√âTECT√âS")

## üîß Optimisations Appliqu√©es

- ‚úÖ Nettoyage fichiers temporaires
- ‚úÖ Correction permissions scripts
- ‚úÖ Modernisation filtres Shopify
- ‚úÖ Suppression console.log
- ‚úÖ Validation JSON

## üìà R√©sultat

- **Synchronisation**: $([ "$SYNC_NEEDED" == "true" ] && echo "‚úÖ COMPL√àTE" || echo "‚ÑπÔ∏è NON N√âCESSAIRE")
- **Backup cr√©√©**: $BACKUP_BRANCH
- **Push status**: ‚úÖ R√âUSSI

## üìã Logs Complets

\`\`\`
$(cat "$LOG_FILE")
\`\`\`

---
*ü§ñ Rapport g√©n√©r√© automatiquement*
EOF

    echo -e "${GREEN}üìÑ Rapport sauvegard√©: $REPORT_FILE${NC}"
}

# Fonction principale
main() {
    echo -e "${PURPLE}üéØ D√©marrage de la synchronisation en mode: $MODE${NC}"

    # √âtapes de validation
    check_prerequisites
    analyze_repository_state
    security_audit

    # Si pas de sync n√©cessaire, on s'arr√™te
    if [ "$SYNC_NEEDED" != "true" ]; then
        echo -e "${GREEN}‚úÖ Repository d√©j√† synchronis√©, aucune action n√©cessaire${NC}"
        exit 0
    fi

    # Validation conditionnelle
    if [ "$MODE" == "safe" ] || [ "$MODE" == "quick" ]; then
        validate_files
    fi

    # Backup de s√©curit√©
    if [ "$MODE" == "safe" ]; then
        create_backup
    fi

    # Nettoyage et optimisations
    intelligent_cleanup

    # Commit et push
    intelligent_commit
    smart_push

    # Rapport final
    generate_report

    echo ""
    echo -e "${GREEN}üéâ SYNCHRONISATION TERMIN√âE AVEC SUCC√àS!${NC}"
    echo -e "${BLUE}üìä Consultez le rapport: $REPORT_FILE${NC}"
    echo -e "${BLUE}üìã Logs d√©taill√©s: $LOG_FILE${NC}"
}

# Gestion des arguments
case "$MODE" in
    "quick")
        echo -e "${YELLOW}‚ö° Mode Quick: Synchronisation rapide sans backup${NC}"
        ;;
    "safe")
        echo -e "${GREEN}üõ°Ô∏è Mode Safe: Synchronisation avec backup et validations${NC}"
        ;;
    "force")
        echo -e "${RED}üí™ Mode Force: Synchronisation forc√©e (ignore les erreurs)${NC}"
        ;;
    *)
        echo -e "${RED}‚ùå Mode invalide: $MODE${NC}"
        echo "Modes disponibles: quick, safe, force"
        exit 1
        ;;
esac

# Ex√©cuter la fonction principale
main "$@"
